# Протокол управления SNMP

**Simple Network Management Protocol (SNMP)** — это протокол прикладного уровня, он делает возможным обмен данными между сетевыми устройствами. SNMP — это не продукт, а свод правил. Он определен Советом по архитектуре Интернета и является частью пакета TCP/IP. SNMP управляется и поддерживается Инженерной группой Интернета (IETF). 

Протокол позволяет системному администратору проводить мониторинг, контролировать производительность сети и изменять конфигурацию подключенных устройств. SNMP используют в сетях любого размера: чем крупнее сеть, тем лучше раскрываются преимущества протокола. Он позволяет просматривать, контролировать и управлять узлами через единый интерфейс с функциями пакетных команд и автоматического оповещения. 

Таким образом, SNMP избавляет администратора от необходимости ввода команд вручную. Всего были разработаны и развернуты три версии. Все они используются до сих пор, а самой распространенной стала вторая — *SNMPv2с*.

## Архитектура SNMP

![[1500х800-1-2048x1795.png]]

Компоненты, составляющие архитектуру SNMP:

- сетевая станция управления, включающая в себя сетевого менеджера;
- агенты;
- мастер-агенты;
- управляемые компоненты.
### Сетевая станция управления — NMS
Network Management Station (NMS) удаленно мониторит управляемые устройства, получает данные, собранные мастер-агентами, отслеживает производительность и представляет полученную информацию в графическом виде. Встроенный менеджер NMS отвечает за связь с агентами.
### Агенты

#### Мастер-агент
Это программа, связывающая сетевых менеджеров и субагентов. Мастер-агент анализирует запросы сетевого менеджера NMS и пересылает их субагентам, собирает и формирует ответы субагентов и отправляет их менеджеру. Мастер-агент уведомляет менеджера, если запрос некорректен или запрошенная информация недоступна.

#### Субагент
Это программа, поставляемая вендором вместе с сетевым устройством. Субагент пересылает собранную информацию мастер-агенту. У каждого управляемого компонента есть соответствующий субагент.

### База управляющей информации — MIB
**MIB** — это иерархическая база данных со сведениями об устройстве. У каждого типа устройства своя MIB-таблица: у принтера в ней содержится информация о состоянии картриджей, а у коммутатора — данные о трафике. Благодаря MIB менеджер знает, какую информацию он может запросить у агента устройства.

## Теория и логика работы протокола SNMP

### Предназначение
Изначально протокол должен был предоставить системным администраторам инструмент для управления интернетом. Однако, гибкая архитектура SNMP позволила проводить мониторинг всех сетевых устройств и управлять ими с одной консоли. Это и стало причиной распространения SNMP.

### PDU
Менеджеры и агенты обмениваются данными через протокол UDP. Вместо него также может использоваться TCP, IPX или протокол MAC-уровня. Обмен данными основан на Protocol Data Unit (PDU).

Всего в SNMP семь PDU: 

- *GET* — запрос менеджера NMS на получение данных c устройства.
- *GETNEXT* — запрос, аналогичный GET. Отличие лишь в том, что менеджер запрашивает данные, находящиеся на следующем уровне иерархии OID, в MIB. 
- *SET* — с помощью этого запроса менеджер изменяет или присваивает устройству новые данные. 
- *RESPONSE* — сообщение от агента, высылаемое в ответ на запрос данных.
- TRAP — уведомление о произошедшем событии или ошибке. Агент отправляет его сразу после наступления события, не дожидаясь запроса менеджера. Менеджер никак не подтверждает получение сообщения, что может стать проблемой.
- *GETBULK* — запрос агенту на извлечение с устройства массива данных. Это улучшенный вариант запроса GETNEXT.
- *INFORM* — сообщение, аналогичное TRAP, но с подтверждением получения. Агент будет отправлять уведомление, пока менеджер не подтвердит, что оно дошло.

INFORM, GETBULK — есть только во второй и третьей версиях протокола SNMP.

#### Схема PDU
| IP заголовок               | TCP/IP                                                   | TCP/IP |
| -------------------------- | -------------------------------------------------------- | ------ |
| UDP заголовок              | TCP/IP                                                   | TCP/IP |
| Версия SNMP                | v1/v2/v3                                                 | PDU    |
| Строка   <br>сообщества    | Public, Private                                          | PDU    |
| Тип PDU                    | Get, GetNext, Response, Set, Trap, GetBulk,   <br>Inform | PDU    |
| ID запроса                 | Идентификатор запроса                                    | PDU    |
| Статус ошибки              | 0, 1, 2, 3, 4, 5                                         | PDU    |
| Индекс ошибки              | 0, 1                                                     | PDU    |
| Связанные   <br>переменные | Одна или несколько переменных в   <br>запросе            | PDU    |
### Сетевые порты SNMP
По умолчанию SNMP использует UDP-порты 161 и 162. Менеджер отправляет запросы на порт 161 агента. С порта 161 агент отправляет ответ менеджеру. При отправке запроса менеджер добавляет к нему ID, а агент вставляет этот ID в ответ, чтобы менеджер мог связать свой запрос с ответом агента.

Ловушки агент высылает на порт 162 менеджера. Если используется DLTS или TLS, то агент высылает сообщения на порт 10162, а менеджер — на порт 10161. Администратор может изменить порты SNMP, используемые по умолчанию, на любые другие.

### Ловушки
Ловушка (Trap) — это важнейший способ коммуникации в SNMP. Менеджер отвечает за большое количество устройств, на многих из них может быть несколько управляемых компонентов. Агент отправляет ловушку по своей инициативе, когда необходимо сообщить менеджеру о событии. Например, ловушка может выслать отчет о перегреве машины или о том, что в тонере закончились чернила.

Получив уведомление, менеджер выбирает нужное действие, например, опрашивает агента, чтобы получить полное представление о том, что произошло. Перечень уведомлений, которые посылает ловушка:

- 0 — **coldStart** — Холодный запуск устройства.
- 1 — **warmStart** — Горячий запуск устройства. 
- 2 — **linkDown** — Интерфейс отключился.
- 3 — **linkUp** — Интерфейс включился.
- 4 — **authenticationFailure** — Менеджер выслал сообщение с неверной строкой сообщества.
- 5 — **egpNeighborLoss** — Агент потерял связь с хостом по протоколу Exterior Gateway Protocol (EGP).
- 6 — **entrpriseSpecific** — Произошло событие, характерное для производителя данного устройства.

В SNMP есть два типа ловушек: Trap и Inform. Отличия между ними в том, что после получения Inform менеджер подтверждает получение ловушки. В противном случае агент будет отправлять Inform, пока не получит подтверждения. А вот после получения Trap менеджер не отправляет подтверждение. Если сообщение не дошло до менеджера, агент об этом не узнает.

---
# Протокол обнаружения канального уровня (LLDP)

**LLDP** расшифровывается как протокол обнаружения канального уровня. Это открытый протокол уровня 2 стандарта IEEE (802.1AB). 

**LLDP** - это альтернатива с открытым исходным кодом для [CDP (Cisco Discovery Protocol)](https://translated.turbopages.org/proxy_u/en-ru.ru.2396fb82-655c4b36-0d6a999f-74722d776562/https/www.geeksforgeeks.org/cisco-discovery-protocol-cdp-and-link-layer-discovery-protocol-lldp-in-data-link-layer/), который также является протоколом обнаружения устройств, который работает на уровне 2 (канальный уровень передачи данных) только на устройствах производства Cisco (маршрутизаторах, мостах, серверах доступа и коммутаторах).

LLDP работает на канальном уровне передачи данных, который позволяет двум разным устройствам собирать аппаратную и протокольную информацию о соседних устройствах, которая полезна при устранении неполадок в сети.

Он поддерживает определенный набор атрибутов, которые он использует для обнаружения соседних устройств и называются **TLV**, которые являются следующими:
- **T- тип** 
- **L- длина**
- **Описания значений V**

Устройства, использующие LLDP на одном из своих интерфейсов, используют TLV для получения и отправки информации своим соседям. Эти устройства хранят информацию о соседних устройствах в локальной таблице, доступ к которой возможен с помощью SNMP (Simple Network Management Protocol). Информация, хранящаяся устройствами, включает:
- Название и описание системы
- Название и описание порта
- IP-адрес для управления
- VLAN
- Возможности соседнего устройства
- MAC-адрес
- Мощность MDI
- Агрегирование каналов

**Формат пакета LLDP**   
LLDP :информация передается и / или принимается соседними устройствами через каждый из их интерфейсов с поддержкой LLDP через фиксированный интервал времени в форме. Каждый кадр Ethernet содержит блок данных LLDP (LLDPDU). LLDPDU представляет собой последовательность структур TLV. Фрейм LLDP ethernet начинается со следующих обязательных TLV :
- Идентификатор шасси
- Идентификатор порта
- Время жить (TTL)

![[LLDPPacketFormat-660x428.png]]

---
# HTTP 0.9/1.0/1.1

> Напоминание! Для передачи двоичных данных по не двоичному протоколу используется протокол MIME. 

**HTTP (протокол передачи Hypertext)** - это способ передачи данных во всемирной сети (не путать с Интернетом, [есть разница](https://www.bbc.co.uk/newsround/av/47523993)). Есть 3 основные версии, и мы пройдем каждую из них здесь.

Проще говоря, протокол определяет, как браузер разговаривает с сервером для передачи данных туда и обратно. Во всех версиях протокола браузер будет запрашивать что-то ("запрос"), а сервер будет отправлять обратно данные ("ответ"). Это простая концепция, но со временем все усложнилось, и как веб-разработчикам важно понять, чем отличаются более поздние версии протокола.

## HTTP/1.x

Выпущенная примерно в 1996 году, первая версия была HTTP/1.0. HTTP/1.1 был выпущен в 1999 году и быстро был принят.

HTTP/1.1 - довольно простая концепция. Давайте посмотрим, как будет работать запрос:

1. Вы переходите на веб-сайт, скажем, [accreditly.io](https://accreditly.io/) в этом примере (для бесстыдной вилки). Ваш браузер отправляет `GET`-запрос на сервер:

```
GET accreditly.io
```

1. Сервер получает запрос и ответ вместе с документом:

```
200 OK

<html>
  <head>
    <title>Accreditly - Web Development Certifications</title>
    [...]
```

1. В этом документе, вероятно, есть различные активы. Такие вещи, как изображения, таблицы стилей (CSS-файлы) и ресурсы JavaScript (.js-файлы). Ваш браузер считывает документ и повторяет шаги 1 и 2 для каждого актива в очереди.

Это простой поток, который довольно легко понять, но здесь есть несколько проблем:

а. Блокировка заголовка линии: каждое соединение HTTP/1.x могло обрабатывать только один запрос одновременно. Это ограничение часто приводило к неэффективному использованию сетевых ресурсов, так как последующие запросы должны были ждать завершения предыдущего запроса.

б. Отсутствие приоритизации: HTTP/1.x не предлагал способа приоритизировать запросы, что может привести к тому, что менее важные ресурсы будут блокировать более важные.

с. Есть и другие проблемы, такие как отправка простых текстовых заголовков, которые являются большими, особенно когда используются файлы cookie.

Все эти проблемы оказывают большое влияние на производительность, особенно в современной сети.

---
## HTTP/2

Входит HTTP/2, выпущенный в 2015 году. Целью HTTP/2 было решение вопросов, поднятых выше. Интернет изменился за 16 лет, когда HTTP/1.1 был королем, у людей есть мобильные устройства на менее стабильных 4G-соединениях, стационарные соединения имеют огромные возможности пропускной способности по сравнению с 90-х годами (набор, кто-нибудь?), но веб-сайты также огромны по сравнению с тем, что они были раньше.

Средний размер веб-страницы теперь огромен по сравнению с тем, что было. Кроме того, веб-страницы в настоящее время загружают активы со скоростью, которая растет гораздо быстрее, чем скорость наших соединений. Согласно HTTP Archive, средний размер изображения на веб-странице вырос более чем на 8000%, как и количество изображений, и это еще до того, как мы перейдем к JavaScript и другим ресурсам. Это большая проблема.

Так как же HTTP/2 помогает?

В HTTP/2 представлен ряд функций, с основным преимуществом, которое люди сосредотачиваются на **мультиплексинге**.

### Мультиплексирование

Посмотрите на наш пример выше в HTTP/1.1, где ваш браузер запрашивает документ с несколькими активами. В HTTP/1.1 эти запросы на активы ставятся в очередь и запрашиваются по одному.

В HTTP/2 это работает немного по-другому. Используя мультиплексирование, браузер эффективно запрашивает активы вместе, а затем получает их таким же образом, все по одному и тому же соединению.

![[j5xz0mk7s1ibpdemjzd6.png]]

### Другие преимущества

В дополнение к мультиплексингу HTTP/2 также реализует некоторые другие функции, уделяя особое внимание производительности:

1. Сжатие заголовка: HTTP/2 использует алгоритм HPACK для сжатия заголовков запросов и ответов, значительно уменьшая объем передаваемых данных.
2. Серверный push: с помощью HTTP/2 серверы могут проактивно выводить ресурсы в кэш клиента до того, как они будут запрошены, уменьшая задержку и улучшая общий пользовательский опыт.
3. Приоритизация потока: HTTP/2 позволяет клиентам расставлять приоритеты запросов, позволяя сначала извлекать и выполнять более важные ресурсы.
4. Двоичное обрамление: HTTP/2 использует слой двоичного обрамления для инкапсуляции сообщений, что делает протокол более эффективным и менее подверженным ошибкам по сравнению с текстовым подходом HTTP/1.x.

HTTP/2 полагается на один и тот же базовый протокол для работы: TCP. Это как положительно, так и отрицательно. Поскольку TCP уже используется HTTP/1.x, это означает, что внедрение намного проще; браузерам не нужно реализовывать новый базовый протокол, и серверы могут продолжать работать так же, как и сейчас, с несколькими настройками для реализации функций HTTP/2. Недостатком является то, что есть проблемы с TCP, особенно в сетях с высокой задержкой и потерями.

## Представляем HTTP/3

HTTP/3 поквидеет TCP и вместо этого использует вариант UDP под названием **Quick UDP Internet Connections** или «QUIC» (смотрите, что они там сделали?).

QUIC имеет несколько преимуществ:

1. Встроенное шифрование: QUIC по умолчанию включает в себя Transport Layer Security (TLS) 1.3, обеспечивая безопасное соединение без необходимости отдельного рукопожатия TLS. Это уменьшает задержку и улучшает время установления соединения.
2. Уменьшенная блокировка заголовка линии: в отличие от TCP, QUIC обрабатывает потерю пакетов на уровне отдельного потока. Это означает, что потеря одного пакета не блокирует все соединение, что еще больше снижает проблемы с блокировкой заголовка линии.
3. Миграция подключений: QUIC предназначен для лучшей поддержки миграции подключений, позволяя клиентам изменять IP-адреса без потери подключения или дополнительной задержки. То, что принесет пользу пользователям мобильных/целлюарных подключений, в частности.
4. Установление соединения 0-RTT: QUIC позволяет установить соединение 0-RTT (ноль времени в оба тура) в определенных ситуациях, что может значительно уменьшить задержку при подключении к ранее посещенному серверу.
5. Улучшенный контроль перегрузки: QUIC предлагает более продвинутые механизмы контроля перегрузки, позволяющие лучше адаптироваться к различным условиям сети и улучшить общую производительность.

HTTP/3 и QUIC звучат отлично, верно?

Ну, да, в теории. Проблема в том, что перед браузерами и поставщиками стоит большая задача реализовать эти функции, не говоря уже о проблемах совместимости с сетевой инфраструктурой.

Многие крупные сети вообще не поддерживают UDP, поэтому проложить трафик по новому протоколу, который находится поверх UDP, потенциально далеко.

Тем не менее, крупные игроки, такие как [Cloudflare](https://www.cloudflare.com/en-gb/learning/performance/what-is-http3/), делают большие скачки вперед, предлагая поддержку HTTP/3 для своих клиентов, а такие браузеры, как Chrome, Edge и Firefox, также имеют поддержку. Вы можете заметить, что Safari нет в этом списке; Apple обычно опаздывает на вечеринку, предлагая поддержку новых функций и протоколов и часто реализует свою собственную версию. Согласно [CanIUse](https://caniuse.com/http3), Safari имеет частичную поддержку HTTP/3, и он доступен только для некоторых пользователей. Имейте в виду, что HTTP/3 еще официально не выпущен, так что все может измениться.

---

Next door: 