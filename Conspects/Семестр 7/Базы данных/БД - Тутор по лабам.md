# Лаба 1

1. Пишем **простые запросы**:

```sql
# 1. Вывести email плательщика, валюту, число операций в валюте, сумму операций в валюте, соритровка  

SELECT currency, count(*) as ops_count, sum(sum) as ops_sum  
FROM billing_simple.billing  
GROUP BY currency  
ORDER BY ops_count, ops_sum DESC;  
  
INSERT INTO billing_simple.billing  
SELECT *  
FROM billing_simple.billing  
WHERE currency = 'INR'  
ORDER BY sum  
LIMIT 1;  
  
  
# 2. Вывести из получившихся строк только те, сумма операций по которым равна максимуму/минимуму  

WITH tab(currency, ops_count, ops_sum) AS (  
	SELECT currency, count(*) as ops_count, sum(sum) as ops_sum  
	FROM billing_simple.billing  
	GROUP BY currency  
	ORDER BY ops_count, ops_sum DESC  
)  
SELECT *  
FROM tab  
WHERE ops_count = (  
	SELECT max(ops_count)  
	FROM tab  
) OR ops_count = (  
	SELECT min(ops_count)  
	FROM tab  
);
```

2. Нужно добавить в таблицу строку, чтобы собралось несколько групп с минимальным значением по количеству транзакций.

3. Создать резервный атрибут (`cur2`) и скопировать в него значение `currency`. 
4. Сделать UPDATE записей в таблице (поменять `currency` всех валют, входящих в минимальное число транзакций на ту, что является максимальной).
5. Повторить запрос выборки максимумов-минимумов (ранее входящие в минимумы должны прибавиться к максимуму, появятся новые минимумы).
6. Откатить изменения `currency` по резервной копии из `cur2`.

**-- Вы сдали 1-ю лабу --**

---
# Лаба 2

![[DBtutor1.png | 500]]

1. Выведите все позиции списка товаров принадлежащие какой-либо категории с названиями товаров и названиями категорий. Список должен быть отсортирован по названию товара, названию категории. Для соединения таблиц необходимо использовать оператор **INNER JOIN**.  

| good_name   | category_name  |  
|-------------|----------------|
| good 1      | category 1     |  
| good 1      | category 2     |  
| good 2      | category 3     |  
| good 2      | category 4     |  
| good 3      | category 7     |  

```sql
SELECT cat.name, goo.name  
FROM store.category as cat  
INNER JOIN store.category_has_good as catgoo  
	ON cat.id = catgoo.category_id  
INNER JOIN store.good as goo  
	ON catgoo.good_id = goo.id
ORDER BY goo.name, cat.name;
```

---

2. Выведите список клиентов (имя, фамилия) и количество заказов данных клиентов, имеющих статус "new".  

| first_name | last_name  | new_sale_num |
| ----- | ---- | ------ |
| Ivan       | Ivanov     | 10           |
| Petr       | Petrov     | 7            |
| Semen      | Sidorov    | 7            |
| Frank      | Sinatra    | 2            |
| Ella       | Fitzgerald | 1            |

```sql
SELECT first_name, last_name, tab.count  
FROM store.client cli  
JOIN (
	SELECT code, count(*) as count  
	FROM (
		SELECT c.code, c.first_name, c.last_name  
		FROM store.client as c  
		INNER JOIN store.sale as sa  
			ON c.id = sa.client_id  
		INNER JOIN store.status as st  
			ON sa.status_id = st.id  
		WHERE st.name = 'new'
	) as tab  
	GROUP BY code  
) as tab 
ON cli.code = tab.code;
```

---

3. Выведите список товаров с названиями товаров и названиями категорий, в том числе товаров, не принадлежащих ни одной из категорий.  

| good_name | category_name |
| --------- | ------------- |
| good 1    | category 1    |
| good 1    | category 2    |
| good 2    | category 3    |
| good 2    | category 4    |
| good 3    | category 7    |

```sql
SELECT goo.name, cat.name  
FROM store.category as cat  
RIGHT JOIN store.category_has_good as catgoo  
	ON cat.id = catgoo.category_id  
RIGHT JOIN store.good as goo  
	ON catgoo.good_id = goo.id;
```

---

4. Выведите список товаров с названиями категорий, в том числе товаров, не принадлежащих ни к одной из категорий, в том числе категорий не содержащих ни одного товара.  

| good_name | category_name |
| --------- | ------------- |
| good 1    | category 1    |
| good 1    | category 2    |
| good 2    | category 3    |
| good 2    | category 4    |
| good 3    | category 7    |

```sql

```

---

5. Выведите список всех источников клиентов и суммарный объем заказов по каждому источнику. Результат должен включать также записи для источников, по которым не было заказов.  

| source_name | sale_sum       |  
|-------------|----------------|
| source 1    | 111.00         |  
| source 2    | 222.00         |  
| source 3    | 333.00         |

```sql

```

---

6. Выведите названия товаров, которые относятся к категории 'Cakes' или фигурируют в заказах текущий статус которых 'delivering'. Результат не должен содержать одинаковых записей. В запросе необходимо использовать оператор UNION для объединения выборок по разным условиям.  

| good_name   |  
|-------------|
| good 1      |  
| good 2      |  
| good 3      |

```sql

```

---

7. Выведите список всех категорий продуктов и количество продаж товаров, относящихся к данной категории. Под количеством продаж товаров подразумевается суммарное количество единиц товара данной категории, фигурирующих в заказах с любым статусом.  

| name                | sale_num |  
|---------------------|----------|
| category 1          |       11 |  
| category 2          |       25 |  
| category 3        |       13 |

```sql

```

---

8. Выведите список источников, из которых не было клиентов, либо клиенты пришедшие из которых не совершали заказов или отказывались от заказов. Под клиентами, которые отказывались от заказов, необходимо понимать клиентов, у которых есть заказы, которые на момент выполнения запроса находятся в состоянии 'rejected'. В запросе необходимо использовать оператор UNION для объединения выборок по разным условиям.  

| source_name |
| ----------- |
| source 1    |
| source 2    |
| source 3    |

```sql

```

---

