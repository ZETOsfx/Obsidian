## <font style="color:#03b1fc" >План на семестр</font>

- Много нового интересного 
- Курсача нет, только лабы (3 письменных отчета + 2 устных) и экзамен

**Лабы:**
1. *Разработка менеджера управления оперативной памятью* (запрос блока памяти через malloc и управление этим куском памяти) - ***эта + некст неделя***
2. *Моделирование работы дика подсистемы* (устный отчет по рабочему фрагменту программы)
3. *Написание программ для мультипроцессорного кластера* (показать работу программы на мультипроцессорном кластере сервера)

*Индивидуально задание:*
- разбиение попарно на бригады с заданием 
- выполнение конкретной задачи на бригаду

Каждый модуль заканчивается РК. 
График выполнения и защиты лабораторных работ есть в журнале у Шефа.

КТО СДАЕТ ВСЕ ЛАБЫ ДО ПОСЛЕДНЕЙ ЛЕКЦИИ - ***ЭКЗАМЕН АВТОМАТОМ***

---
#### <font style="color:#03b1fc">Работа с ОП</font>

Управление оперативной памятью:

1. В свободную оперативную память поступают процессы, требующие выполнения. Операционная система нарезает процессы и распределяет их по оперативной памяти.
2. После частичного выполнения процессов в оперативной памяти появляются "дыры", которые заполняются ОС-й новыми процессами из очереди.

***Дыра*** - определенный фрагмент, выделить его как непрерывный участок памяти нельзя. При объединении нескольких "дыр" можно получить продолжительный участок памяти, возможный под резервирование более емкими процессами из очереди.

![[ОП1.jpeg | 300]]

Здесь есть 2 нюанса:
- Если дыры слишком маленькие (что с ними делать?)
	- V1: пусть будут
	- V2: они создают проблемы с ОП (ОС будет дополнительно тратить ресурсы для них) - мы задаемся минимальным размером, меньше которого дыру создать нельзя / либо же уплотнение памяти - сдвиг все процессы сдвигаются к началу или концу (перемещающий загрузчик)

- Метод определения "дыры" для нового процесса:
	- Метод первого подходящего (все дыры лежат в списке, первая подходящая по списку выбирается для нового процесса. требует минимум затрат от процессора)
	- Метод следующего подходящего (поиск первого подходящего с фиксацией метки, возобновляя поиск от метки, а не от начала оперативной памяти) - в среднем наиболее оптимальный
	- Метод наилучшего подходящего (предполагает поиск оптимального размера дыры для конкретного процесса - но требует затрат для поиска такой дыры)
	- Метод наихудшего подходящего (обратный подход - отрезая от большой дыры оставшуюся часть мы получаем большую дыру, в которую чаще всего еще можно что-то разместить)


Управление освобождающимися участками памяти. Методы управления:

- Связный список (упорядочивание по возрастанию адресов памяти - позволяет проверять, не являются ли соседние элементы смежными)

![[ОП2.jpeg | 300]]

- Метод Дональда трампа Кнута (метод этикеток) - каждый блок и дыра имеют в начале и в конце "этикетки" с данными о размере блока и адресе начала блока. Смежность блоков определяется по памяти методом обращения "к заднему байту" - получаем этикетку предыдущего (или некст) блока.

![[ОП3.jpeg | 250]] ![[ОП4.jpeg | 250]]

А че, а если свободен? Заглядываем на блок вперед и видим его загруженность. Если соседние блоки свободны - исключаем из списка второй блок и переносим его этикетку в конец, обновляя информацию о размере блока.

- Метод двойников (нет никаких указателей, всю оперативную память делим на половины).

---

> В реальных ситуациях возникает возможность загружать лишь необходимую часть программы в ОП вместо всей целиком. 

**В таких условиях на первый план выходят 2 метода: 

- <font style="color:#ffb640">"Метод оверлеев"</font> - в большинстве своем каждая программа имеет древовидную структуру, при которой есть возможность загружать лишь одно поддерево, когда не существует ситуаций, когда два узла одного уровня могут использоваться одновременно.

- <font style="color:#ffb640">"Своппинг"</font> - при необходимости кусок оперативной памяти можно выгрузить и сохранить в разделе подкачки (в условиях дефицита нехватки ОП).

---

Все виртуальные ресурсы реальны. От реальных отличие лишь в том, что происходит подмена представления для ОС. 

Благодаря свойству локальности при выполнении каждой программы часто нужен лишь небольшой кусок программы, который и должен быть загружен в ОП вместо всей программы целиком. 

При этом необходимо четко знать моменты подгрузки новых фрагментов программы. Таким же образом разные фрагменты одной программы могут быть подгружены в разные области ОП. 

---

На практике данные фрагменты программы представлены в виде блоков, которые со временем подгружаются в ОП по мере надобности. 

-> Вся программа представлена в виде блоков
-> Одновременно в ОП загружается (в разные места) несколько блоков и устанавливаются связи между ними
-> Указатель на "корень" данной связи является виртуальным адресом

-> В ОП размещается таблица, а в процессоре есть спец. регистр, который указывает на данную таблицу:

	1. При выполнении определенной команды процессор получает адрес таблиы
	2. В таблице через смещение определяется запись о наличии блока в ОП 
	3. Если блока нет, то происходит загрузка блока в ОП определенным методом
	4. Если блок есть, или уже был загружен, то происходит установка связей с другими блоками и обновление таблицы. 
	5. Блок используется для выполнения необходимого фрагмента программы 

---

Next door: [[Семестр 7/Операционные системы/ОС - Лекция 2]]
