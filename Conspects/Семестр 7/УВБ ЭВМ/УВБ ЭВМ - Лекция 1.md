Балуев Владимир Валерьевич (человек приходящий): 
	+7 (903) 519-60-53
	+7 (977) 621-47-86
	--- Номера особо не понадобятся, у него уже есть контакты старост
## <font style="color:#03b1fc" >План на семестр</font>

1. <font style="color:#ffb640">Бортовые ЭВМ</font> (в основном) - класс ЭВМ, для корректного функционирования которого требуются специальные требования.
2. Экзамен не сложный (договорной - на крайняк за касарь пропустишь)

---

Next door: 

```c
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

// Вывод байтов побитово
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0') 

// Округление вверх
int ceilUp(int a, int b)
{
    return a / b + ((a % b) ? 1 : 0);
}

void fillBitmap(unsigned char* bitmap, int index, int size, char val)
{
    for (int i = index; i < index + size; i++){
        if (val == 0) {
            bitmap[i / 8] &= ~(1 << (7 - i % 8));
        } else {
            bitmap[i / 8] |= (1 << (7 - i % 8));
        }
    }
}

typedef struct bitmapMemory
{
    unsigned char* pool;     // Пул
    unsigned char* bitmap;   // Карта
    int blocks;              // Количество блоков
    int mapFactor;           // Размер блока
    int minSize;             // Размер малой дыры
};

struct bitmapMemory initBMM(int blocks, int factor, int minSize)
{
    struct bitmapMemory result;
    result.blocks = blocks;
    result.pool = malloc(blocks * factor);
    result.mapFactor = factor;
    result.bitmap = calloc(ceilUp(blocks, 8), 1);
    result.minSize = minSize;
    return result;
}

void freeBMM(struct bitmapMemory bmm)
{
    free(bmm.mapFactor);
    free(bmm.bitmap);
}
  
void printBitmap(unsigned char* mem, int size)
{
    for (int i = 0; i < size; i++) {
        if (!(i % 8)) 
            printf("\n");
        printf(BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(mem[i]));
        printf(" ");
    }
    printf("\n");
}
  
void* _malloc(unsigned int size, struct bitmapMemory bmm)
{
    void* result;
    int bestBmmIndex = -1;
    unsigned int bestBmmSize = 0xFFFFFFFF;
    int targetSize = size + sizeof(int);
    int curBmmByte = -1;
    int rowCnt = 0;
    unsigned char bmmByteBuffer = bmm.bitmap[curBmmByte];

    // Поиск наилучшего подходящего места
    for (int i = 0; i < bmm.blocks; i++){
        // Переключение байта
        if (!(i % 8)) {
            bmmByteBuffer = bmm.bitmap[++curBmmByte];
        }
        
        // Побитовый обход
        if (!(bmmByteBuffer & 0x80) && (i != bmm.blocks - 1)) 
            rowCnt++;
        else {
            // Сохранение наилучшего варианта
            if ((rowCnt * bmm.mapFactor > targetSize) && (rowCnt < bestBmmSize)) {
                bestBmmIndex = i - rowCnt;
                bestBmmSize = rowCnt;
            }
            rowCnt = 0;
        }
        bmmByteBuffer <<= 1;
    }
    
    // Если место не найдено - возврат 0
    if (bestBmmIndex == -1) 
        return 0;
        
    // Проверка образования малой дыры
    if (bestBmmSize * bmm.mapFactor - targetSize > bmm.minSize) {
        bestBmmSize = targetSize;
    } else {
        bestBmmSize *= bmm.mapFactor;
    }

    // Сохранение размера блока в первые 4 байта
    ((unsigned int*)(bmm.pool + (bestBmmIndex * bmm.mapFactor)))[0] = ceilUp(bestBmmSize, bmm.mapFactor);
    unsigned char* result = bmm.pool + bestBmmIndex * bmm.mapFactor + sizeof(int);
    fillBitmap(bmm.bitmap, bestBmmIndex, ceilUp(bestBmmSize, bmm.mapFactor) , 1);
    printf("New block [%p - %p]\n", result, result + ceilUp(bestBmmSize, bmm.mapFactor));

    return result;
}

void _free(unsigned char* mem, struct bitmapMemory bmm) 
{
    int bmmIndex = (mem - bmm.pool - sizeof(int)) / bmm.mapFactor;
    int size = ((unsigned int*)mem)[-1];
    printf("Freed block [%p - %p]\n", mem, mem + bmmIndex * bmm.mapFactor);
    fillBitmap(bmm.bitmap, bmmIndex, size, 0);
}

int main(int argc, char** argv)
{
    struct bitmapMemory bmm = initBMM(0x5C, 4, 8);
    memset(bmm.pool, 0, bmm.blocks * bmm.mapFactor);
    printBitmap(bmm.bitmap, ceilUp(bmm.blocks, 8));
    void* newMem = _malloc(26, bmm);
    void* newMem2 = _malloc(26, bmm);
    printBitmap(bmm.bitmap, ceilUp(bmm.blocks, 8));
    printf("\n");
  
    for (int i = 22; i >= 16; i -= 2) {
        _free(newMem, bmm);
        printBitmap(bmm.bitmap, ceilUp(bmm.blocks, 8));
        printf("Requested size - %i\n", i);
        newMem = _malloc(i, bmm);
        printBitmap(bmm.bitmap, ceilUp(bmm.blocks, 8));
        printf("--------------------------------\n");
    }

    freeBMM(bmm);
    return(0);
}
```